import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
import { debounce } from 'lodash';
import { Play, Pause, Users, Film, RefreshCw } from 'lucide-react';
import AppLayout from '@/layouts/app-layout';
import { Head } from '@inertiajs/react';
import { type BreadcrumbItem } from '@/types';

interface Room {
  name: string;
  youtube_video_id: string;
}

interface SyncEvent {
  payload: { event: 'play' | 'pause' | 'seek'; time?: number };
  source?: string;
}

declare global {
  interface Window {
    Pusher: typeof Pusher;
    Echo: Echo<any>;
    YT: any;
    onYouTubeIframeAPIReady: () => void;
  }
}

export default function Watch({ room }: { room: Room }) {

    const breadcrumbs: BreadcrumbItem[] = [
        { title: "Room: " + room.name, href: `/rooms/${room.name}` },
    ];

  // State & refs
  const [videoId, setVideoId] = useState('');
  const [syncEnabled, setSyncEnabled] = useState(true);
  const [syncSource] = useState(`client-${Math.random().toString(36).substr(2, 8)}`);
  const [status, setStatus] = useState('Loading YouTube API...');
  const [error, setError] = useState<string | null>(null);
  const [start, setStart] = useState(false);
  const [usersStarted, setUsersStarted] = useState(0);
  const [userList, setUserList] = useState<string[]>([]);
  const [seekTime, setSeekTime] = useState(0);
  const [duration, setDuration] = useState(0);

  const usersInRoom = userList.length;
  const allUsersStarted = usersInRoom > 0 && usersStarted >= usersInRoom;

  const playerContainerRef = useRef<HTMLDivElement>(null);
  const playerRef = useRef<any>(null);
  const readyRef = useRef(false);
  const mountedRef = useRef(false);
  const apiLoadedRef = useRef(false);
  const rafRef = useRef<number>();

  // Extract video ID
  useEffect(() => {
    try {
      const u = new URL(room.youtube_video_id);
      const v = u.searchParams.get('v') || room.youtube_video_id;
      setVideoId(v);
    } catch {
      setVideoId(room.youtube_video_id);
    }
  }, [room.youtube_video_id]);

  // Load YouTube API
  useEffect(() => {
    if (apiLoadedRef.current) return;
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
    window.onYouTubeIframeAPIReady = () => {
      apiLoadedRef.current = true;
      setStatus('YouTube API ready');
    };
  }, []);

  // Smooth polling via rAF
  const pollTime = () => {
    if (readyRef.current && playerRef.current) {
      setSeekTime(playerRef.current.getCurrentTime());
    }
    if (playerRef.current.getPlayerState() === window.YT.PlayerState.PLAYING) {
      rafRef.current = requestAnimationFrame(pollTime);
    }
  };

  // Initialize player when everyone is ready
  useEffect(() => {
    if (!apiLoadedRef.current || !allUsersStarted || !videoId || !mountedRef.current) return;
    if (playerRef.current) playerRef.current.destroy();

    setStatus('Initializing player...');
    playerRef.current = new window.YT.Player(playerContainerRef.current!, {
      videoId,
      playerVars: {
        autoplay: 0,
        controls: 1,
        rel: 1,
        modestbranding: 1,
        disablekb: 1,
        fs: 0,
        origin: window.location.origin,
      },
      events: {
        onReady: (e: any) => {
          readyRef.current = true;
          setStatus('Player ready');
          setDuration(e.target.getDuration());
        },
        onStateChange: (e: any) => {
          // stop any ongoing rAF
          if (rafRef.current) cancelAnimationFrame(rafRef.current);

          // broadcast sync
          if (syncEnabled) {
            if (e.data === window.YT.PlayerState.PLAYING) sendSync('play');
            if (e.data === window.YT.PlayerState.PAUSED) sendSync('pause');
            if (e.data === window.YT.PlayerState.BUFFERING)
              sendSync('seek', playerRef.current.getCurrentTime());
          }

          // start rAF polling on play
          if (e.data === window.YT.PlayerState.PLAYING) {
            rafRef.current = requestAnimationFrame(pollTime);
          }
        },
      },
    });
  }, [allUsersStarted, videoId]);

  // mount/unmount
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      if (playerRef.current) playerRef.current.destroy();
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, []);

  // Echo setup
  useEffect(() => {
    if (!room.name) return;
    window.Pusher = Pusher;
    Pusher.logToConsole = true;
    window.Echo = new Echo({
      broadcaster: 'pusher',
      key: import.meta.env.VITE_PUSHER_APP_KEY,
      cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
      forceTLS: true,
    });
    const chan = window.Echo.channel(`public-room.${room.name}`);
    const chanS = window.Echo.channel(`public-room-users-started.${room.name}`);

    chan.listen('.sync', handleSyncEvent);
    chan.listen('.user-joined', (d: any) => {
      if (!userList.includes(d.source)) setUserList(u => [...u, d.source]);
    });
    chanS.listen('.user-started', () => setUsersStarted(u => u + 1));

    axios.post(`/api/rooms/${room.name}/user-joined`, { source: syncSource });
    axios.get(`/api/rooms/${room.name}/users`).then(r => setUserList(r.data.users));

    return () => {
      window.Echo.leaveChannel(`public-room.${room.name}`);
      window.Echo.leaveChannel(`public-room-users-started.${room.name}`);
    };
  }, [room.name]);

  // Sync helpers
  const sendSync = debounce((ev: 'play' | 'pause' | 'seek', t?: number) => {
    if (!syncEnabled) return;
    axios.post(`/api/rooms/${room.name}/sync`, { event: ev, time: t, source: syncSource });
  }, 200);

  const handleSyncEvent = (d: SyncEvent) => {
    if (d.source === syncSource || !syncEnabled || !readyRef.current) return;
    const { event, time } = d.payload;
    if (event === 'play') playerRef.current.playVideo();
    if (event === 'pause') playerRef.current.pauseVideo();
    if (event === 'seek' && time != null) playerRef.current.seekTo(time, true);
  };

  // Start & controls
  const doStart = () => {
    setStart(true);
    axios.post(`/api/rooms/${room.name}/user-started`, { source: syncSource });
  };
  const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
    const t = parseFloat(e.target.value);
    setSeekTime(t);
    if (readyRef.current) playerRef.current.seekTo(t, true);
    if (allUsersStarted && syncEnabled) sendSync('seek', t);
  };
  const doPlay = () => readyRef.current ? playerRef.current.playVideo() : setStatus('Not ready');
  const doPause = () => readyRef.current ? playerRef.current.pauseVideo() : setStatus('Not ready');

  return (
    <AppLayout breadcrumbs={breadcrumbs}>
      <Head title="Watch Room" />

      <div className="min-h-screen bg-gray-100 flex items-center justify-center p-4">
        <div className="max-w-3xl w-full bg-white shadow-lg rounded-2xl overflow-hidden">
          {/* Header */}
          <div className="flex items-center justify-between px-6 py-4 border-b">
            <div className="flex items-center space-x-3">
              <Film className="w-6 h-6 text-indigo-600" />
              {/* <h2 className="text-xl font-semibold text-gray-800">Room: {room.name}</h2> */}
            </div>
            <div className="flex items-center space-x-2">
              <label className="flex items-center space-x-1 text-sm text-gray-600">
                <input
                  type="checkbox"
                  checked={syncEnabled}
                  onChange={() => setSyncEnabled(!syncEnabled)}
                  className="h-4 w-4 text-indigo-600 rounded"
                />
                <span>Sync</span>
              </label>
              <Users className="w-5 h-5 text-gray-500" />
              <span className="text-sm font-medium text-gray-700">
                {usersStarted}/{usersInRoom}
              </span>
            </div>
          </div>

          {/* Video or waiting */}
          {allUsersStarted ? (
            <div className="relative aspect-video">
              <div ref={playerContainerRef} className="w-full h-full youtube-player-container" />
            </div>
          ) : (
            <div className="relative bg-black aspect-video flex items-center justify-center">
              {!start ? (
                <button
                  onClick={doStart}
                  className="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full shadow-xl transition"
                >
                  Start
                </button>
              ) : (
                <p className="text-white text-lg">Waiting for othersâ€¦</p>
              )}
            </div>
          )}

          {/* status/error */}
          {status && (
            <div className="px-6 py-2 text-sm text-gray-500">
              Status: <span className="font-medium">{status}</span>
            </div>
          )}
          {error && <div className="px-6 py-2 text-sm text-red-600">{error}</div>}

          {/* Controls */}
          {allUsersStarted && (
            <div className="px-6 py-4 border-t bg-white flex flex-col space-y-4">
              <div className="flex items-center justify-center space-x-6">
                <button onClick={doPlay} className="p-3 bg-indigo-50 rounded-full hover:bg-indigo-100">
                  <Play className="w-6 h-6 text-indigo-600" />
                </button>
                <button onClick={doPause} className="p-3 bg-indigo-50 rounded-full hover:bg-indigo-100">
                  <Pause className="w-6 h-6 text-indigo-600" />
                </button>
                <button
                  onClick={() => {
                    setSeekTime(0);
                    readyRef.current && playerRef.current.seekTo(0, true);
                  }}
                  className="p-3 bg-indigo-50 rounded-full hover:bg-indigo-100"
                >
                  <RefreshCw className="w-6 h-6 text-indigo-600" />
                </button>
              </div>
              <div className="flex items-center space-x-3">
                <span className="text-xs text-gray-600">{seekTime.toFixed(1)}s</span>
                <input
                  type="range"
                  min={0}
                  max={duration}
                  step={0.1}
                  value={seekTime}
                  onChange={handleSeek}
                  className="flex-1 h-1 rounded-lg appearance-none bg-gray-300 accent-indigo-600 cursor-pointer"
                />
                <span className="text-xs text-gray-600">{duration.toFixed(1)}s</span>
              </div>
            </div>
          )}
        </div>
      </div>
    </AppLayout>
  );
}
